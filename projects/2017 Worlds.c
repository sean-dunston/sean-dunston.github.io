#pragma config(I2C_Usage, I2C1, i2cSensors)
#pragma config(Sensor, in1,    Claw_Potentiometer, sensorPotentiometer)
#pragma config(Sensor, in2,    Arm_Potentiometer, sensorPotentiometer)
#pragma config(Sensor, in3,    Dial,           sensorPotentiometer)
#pragma config(Sensor, I2C_1,  Right_Drive_Encoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Sensor, I2C_2,  Left_Drive_Encoder, sensorQuadEncoderOnI2CPort,    , AutoAssign)
#pragma config(Motor,  port1,           Left_Back_Drive, tmotorVex393, openLoop, encoder, encoderPort, I2C_1, 1000)
#pragma config(Motor,  port2,           Left_Front_Drive, tmotorVex393, openLoop)
#pragma config(Motor,  port3,           Left_Claw,     tmotorVex393, openLoop)
#pragma config(Motor,  port4,           Left_Arm_1,    tmotorVex393, openLoop)
#pragma config(Motor,  port5,           Left_Arm_2,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port6,           Right_Arm_2,   tmotorVex393, openLoop)
#pragma config(Motor,  port7,           Right_Arm_1,   tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port8,           Right_Claw,    tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port9,           Right_Front_Drive, tmotorVex393, openLoop, reversed)
#pragma config(Motor,  port10,          Right_Back_Drive, tmotorVex393, openLoop, reversed, encoder, encoderPort, I2C_2, 1000)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

#pragma platform(VEX)

//Competition Control and Duration Settings
#pragma competitionControl(Competition)
#pragma autonomousDuration(20)
#pragma userControlDuration(120)

#include "Vex_Competition_Includes.c"
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Asign Motors And Encoders To Simpler Terms To Work With																																	//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void arm(int power)																																																					//
{																																																														//
	motor[Left_Arm_1] = motor[Left_Arm_2] = motor[Right_Arm_1] = motor[Right_Arm_2] = power;																	//
}																																																														//
void right(int power)																																																				//
{																																																														//
	motor[Right_Back_Drive] = motor[Right_Front_Drive] = power;																																//
}																																																														//
void left(int power)																																																				//
{																																																														//
	motor[Left_Back_Drive] = motor[Left_Front_Drive] = power;																																	//
}																																																														//
void drive(int power)																																																				//
{																																																														//
	motor[Left_Back_Drive] = motor[Left_Front_Drive] = motor[Right_Back_Drive] = motor[Right_Front_Drive] = power;						//
}																																																														//
void claw(int power)																																																				//
{																																																														//
	motor[Left_Claw] = motor[Right_Claw] = power;																																							//
}																																																														//
int rDistance =	abs(SensorValue(Right_Drive_Encoder));																																			//
int lDistance = abs(SensorValue(Left_Drive_Encoder));																																				//
int avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;												//
int armHeight = SensorValue(Arm_Potentiometer);																																							//
int clawPosition = SensorValue(Claw_Potentiometer);																																					//
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

//

//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//Move forward Accelerating off time and decelerating of remaining distance.
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void forward(int distance)
{
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (avgDistance < distance)
	{
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 3;
		int dccel = distance - avgDistance / 2;
		if (dccel < accel)
			drive(dccel);
		else
			drive(accel);
	}
	drive(0);
}
void forw(int distance)
{
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (avgDistance < distance)
	{
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 3;
		drive(accel);
	}
}
void ard(int distance)
{
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (avgDistance < distance)
	{
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int dccel = distance - avgDistance / 2;
		drive(dccel);
	}
	drive(0);
}
void reverse(int distance)
{
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	wait10Msec(1);
	while (avgDistance < distance)
	{
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 3;
		int dccel = distance - avgDistance / 2;
		if (dccel < accel)
			drive(-dccel);
		else
			drive(-accel);
	}
	drive(0);
}
void slowReverse(int distance)
{
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	wait10Msec(1);
	while (avgDistance < distance)
	{
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 1;
		int dccel = distance - avgDistance / 3;
		if (dccel < accel)
			drive(-dccel);
		else
			drive(-accel);
	}
	drive(0);
}
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void raiseReverse(int distance, int height, int power, int trim)
{
	armHeight = 0;
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	wait10Msec(1);
	while ((avgDistance < distance) && (armHeight < height))
	{
		armHeight = SensorValue(Arm_Potentiometer);
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 1;
		int dccel = distance - avgDistance / 3;
		arm(power);
		if (dccel < accel)
			drive(-dccel);
		else if (dccel < 0)
			drive(0);
		else
			drive(-accel);
	}
	drive(0);
	arm(trim);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void lowerReverse(int distance, int height, int power, int trim)
{
	armHeight = 0;
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	wait10Msec(1);
	while ((avgDistance < distance) || (armHeight > height))
	{
		armHeight = SensorValue(Arm_Potentiometer);
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 1;
		int dccel = distance - avgDistance / 3;
		arm(-power);
		if (dccel < accel)
			drive(-dccel);
		else if (dccel < 0)
			drive(0);
		else
			drive(-accel);
	}
	drive(0);
	arm(trim);
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
void leftSwing(int distance)
{
	rDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	while (rDistance < distance)
	{
		rDistance = abs(SensorValue(Right_Drive_Encoder));
		int accel = time10[T1] * 3;
		int dccel = distance - rDistance / 2;
		if (dccel < accel)
			int power = dccel;
		else
			power = accel;
		right(power);
	}
	drive(0);
}
void leftTurn(int distance)
{
	lDistance = 0;
	rDistance = 0;
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (lDistance < distance || rDistance < distance)
	{
		rDistance =	abs(SensorValue(Right_Drive_Encoder));
		lDistance = abs(SensorValue(Left_Drive_Encoder));
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 3;
		int dccel = distance - avgDistance / 2;
		if (dccel < accel)
			int power = dccel;
		else
			power = accel;
		if (lDistance < distance)
			left(-power);
		else
			left(0);
		if (rDistance < distance)
			right(power);
		else
			right(0);
	}
	drive(0);
}
void slowLeftTurn(int distance)
{
	lDistance = 0;
	rDistance = 0;
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (lDistance < distance || rDistance < distance)
	{
		rDistance =	abs(SensorValue(Right_Drive_Encoder));
		lDistance = abs(SensorValue(Left_Drive_Encoder));
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 1.5;
		int dccel = distance - avgDistance / 3;
		if (dccel < accel)
			int power = dccel;
		else
			power = accel;
		if (lDistance < distance)
			left(-power);
		else
			left(0);
		if (rDistance < distance)
			right(power);
		else
			right(0);
	}
	drive(0);
}
void rightSwing(int distance)
{
	lDistance = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	while (lDistance < distance)
	{
		lDistance = abs(SensorValue(Left_Drive_Encoder));
		int accel = time10[T1] * 3;
		int dccel = distance - lDistance / 2;
		if (dccel < accel)
			int power = dccel;
		else
			power = accel;
		left(power);
	}
	drive(0);
}
void rightSwing(int distance, int power)
{
	lDistance = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	while (lDistance < distance)
	{
		lDistance = abs(SensorValue(Left_Drive_Encoder));
		left(power);
	}
	left(0);
}
void rightTurn(int distance)
{
	lDistance = 0;
	rDistance = 0;
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (lDistance < distance || rDistance < distance)
	{
		rDistance =	abs(SensorValue(Right_Drive_Encoder));
		lDistance = abs(SensorValue(Left_Drive_Encoder));
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 3;
		int dccel = distance - avgDistance / 2;
		if (dccel < accel)
			int power = dccel;
		else
			power = accel;
		if (lDistance < distance)
			left(power);
		else
			left(0);
		if (rDistance < distance)
			right(-power);
		else
			right(0);
	}
	drive(0);
}
void slowRightTurn(int distance)
{
	lDistance = 0;
	rDistance = 0;
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (lDistance < distance || rDistance < distance)
	{
		rDistance =	abs(SensorValue(Right_Drive_Encoder));
		lDistance = abs(SensorValue(Left_Drive_Encoder));
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * 1.5;
		int dccel = distance - avgDistance / 3;
		if (dccel < accel)
			int power = dccel;
		else
			power = accel;
		if (lDistance < distance)
			left(power);
		else
			left(0);
		if (rDistance < distance)
			right(-power);
		else
			right(0);
	}
	drive(0);
}
void slowRightTurn(int distance, float integral, int dividen)
{
	lDistance = 0;
	rDistance = 0;
	avgDistance = 0;
	SensorValue(Right_Drive_Encoder) = 0;
	SensorValue(Left_Drive_Encoder) = 0;
	time10[T1] = 0;
	while (avgDistance < distance)
	{
		rDistance =	abs(SensorValue(Right_Drive_Encoder));
		lDistance = abs(SensorValue(Left_Drive_Encoder));
		avgDistance = (abs(SensorValue(Left_Drive_Encoder)) + abs(SensorValue(Right_Drive_Encoder))) / 2;
		int accel = time10[T1] * integral;
		int dccel = distance - avgDistance / dividen;
		if (dccel < accel)
			int power = dccel;
		else
			power = accel;
		if (avgDistance < distance)
		{
			left(power);
			right(-power);
		}
	}
	drive(0);
}
void raise(int height, int power, int trim)
{
	while (armHeight < height)
	{
		armHeight = SensorValue(Arm_Potentiometer);
		arm(power);
	}
	arm(trim);
}
void raise(int height, int trim)
{
	while (armHeight < height)
	{
		armHeight = SensorValue(Arm_Potentiometer);
		arm(127);
	}
	arm(trim);
}
void raise(int height)
{
	while (armHeight < height)
	{
		armHeight = SensorValue(Arm_Potentiometer);
		arm(127);
	}
	arm(0);
}
void lower(int height, int power, int trim)
{
	while (armHeight > height)
	{
		armHeight = SensorValue(Arm_Potentiometer);
		arm(-power);
	}
	arm(trim);
}
void lower(int height, int trim)
{
	while (armHeight > height)
	{
		armHeight = SensorValue(Arm_Potentiometer);
		arm(-50);
	}
	arm(trim);
}
void lower(int height)
{
	while (armHeight > height)
	{
		armHeight = SensorValue(Arm_Potentiometer);
		arm(-50);
	}
	arm(0);
}
void claw(int position, int trim)
{
	time1[T2] = 0;
	clawPosition = SensorValue(Claw_Potentiometer) = 0;
	int DIRECTION = (clawPosition - position);
	int MAX_TIME = abs(DIRECTION);
	if (DIRECTION > 0)
	{
		while (clawPosition > position && time1[T2] < MAX_TIME)
		{
			clawPosition = SensorValue(Claw_Potentiometer);
			claw(127);
		}
		claw(trim);
	}
	else if (DIRECTION < 0)
	{
		while (clawPosition < position && time1[T2] < MAX_TIME)
		{
			clawPosition = SensorValue(Claw_Potentiometer);
			claw(-127);
		}
		claw(trim);
	}
}
void pre_auton()
{
	bStopTasksBetweenModes = true;
}
task autonomous()
{
if (SensorValue(Dial) > 4090) //Run Right Side Full Autonomous
	{
		rDistance =	0;
		lDistance = 0;
		avgDistance = 0;
		armHeight = 0;
		clawPosition = 0;
		SensorValue(Right_Drive_Encoder) = 0;
		SensorValue(Left_Drive_Encoder) = 0;
		claw(975, 5);
		rightSwing(250, 70);
		forward(180);
		//claw(1400, 5);
		//forward(120);
		left(-7);
		right(7);
		claw(3000, -20);
		drive(0);
		raise(1050, 50, 15);
		reverse(100);
		leftTurn(280);
		arm(-10);
		claw(127);
		forw(100);
		claw(1400, 5);
		arm(0);
		ard(950);
		claw(3030, -50);
		raise(2200, 20);
		slowLeftTurn(350);
		slowReverse(540);
		raise(2900, -10);
		claw(127);
		wait10Msec(50);
		claw(2000, -20);
		drive(-80);
		claw(70);
		lower(1100, 100, -5);
		drive(0);
		claw(1500, 10);
		forward(900);
		claw(3070, -50);
		raiseReverse(700, 2800, 80, 10);
		claw(127);
		wait10Msec(100);
		claw(0);
		reverse(200);
		lower(1200, 100, 0);
		reverse(150);
		//lowerReverse(400, 1200, 80, 0);
	}
	else if (SensorValue(Dial) > 3500) //Run Left Side Full Autonomous
	{
		rDistance =	0;
		lDistance = 0;
		avgDistance = 0;
		armHeight = 0;
		clawPosition = 0;
		SensorValue(Right_Drive_Encoder) = 0;
		SensorValue(Left_Drive_Encoder) = 0;
		claw(975, 5);
		leftSwing(250);
		forward(150);
		claw(3000, -20);
		raise(1100, 50, 15);
		reverse(100);
		rightTurn(350);
		arm(-10);
		claw(127);
		forw(100);
		claw(1350, 5);
		arm(0);
		ard(950);
		claw(3050, -50);
		raise(2200, 20);
		slowRightTurn(270);
		slowReverse(450);
		raise(2900, -10);
		claw(127);
		wait10Msec(50);
		lower(1100, 100, 0);
		claw(1500, 10);
		forward(850);
		claw(3070, -50);
		raiseReverse(600, 2800, 80, 10);
		claw(127);
		wait10Msec(100);
		claw(0);
		reverse(200);
		lower(1200, 100, 0);
		reverse(150);
		//lowerReverse(400, 1200, 80, 0);
	}
	else if (SensorValue(Dial) > 2500) //Run Right Side Half Autonomous
	{
		rDistance =	0;
		lDistance = 0;
		avgDistance = 0;
		armHeight = 0;
		clawPosition = 0;
		SensorValue(Right_Drive_Encoder) = 0;
		SensorValue(Left_Drive_Encoder) = 0;
		wait10Msec(1);
		claw(975, 5);
		rightSwing(250, 60);
		forward(150);
		claw(3000, -20);
		reverse(50);
		raise(2200, 100, 15);
		slowRightTurn(250, 1, 4);
		slowReverse(500);
		raise(2800, 50, 0);
		claw(127);
		wait10Msec(100);
		claw(0);
		wait10Msec(50);
		claw(3000, 0);
		lower(1200, 100, 0);
		claw(127);
		wait10Msec(100);
		raise(2500, 127, 0);
		claw(1700, 10);
	}
}
task usercontrol()
{
	while(true)
	{
		int trim;
		bool open;
		bool up;
		bool hang;
		if (vexRT[Btn8D] == 1)
			hang = false;
		if (SensorValue(Arm_Potentiometer) < 1500 && hang)
			trim = - 20;
		else if (SensorValue(Arm_Potentiometer) > 2800)
			trim = 0;
		else if (SensorValue(Arm_Potentiometer) > 2500)
			trim = 10;
		else if (SensorValue(Arm_Potentiometer) > 1400)
			trim =  20;
		else
			trim = 0;

		motor[Left_Back_Drive] = motor[Left_Front_Drive] = (vexRT[Ch3]);
		motor[Right_Back_Drive] = motor[Right_Front_Drive] = (vexRT[Ch2]);


		if (vexRT[Btn5U] == 1)
		{
			up = true;
			hang = false;
			motor[Left_Arm_1] = motor[Left_Arm_2] = motor[Right_Arm_1] = motor[Right_Arm_2] = 127;
		}
		else if (vexRT[Btn5D] == 1)
		{
			up = false;
			motor[Left_Arm_1] = motor[Left_Arm_2] = motor[Right_Arm_1] = motor[Right_Arm_2] = -50;
		}
		else if (vexRT[Btn8R] == 1)
		{
			motor[Right_Back_Drive] = motor[Right_Front_Drive] = 127;
			motor[Left_Back_Drive] = motor[Left_Front_Drive] = 127;
			wait10Msec(50);
			motor[Left_Arm_1] = motor[Left_Arm_2] = motor[Right_Arm_1] = motor[Right_Arm_2] = -127;
			hang = true;
		}
		else if (up)
			motor[Left_Arm_1] = motor[Left_Arm_2] = motor[Right_Arm_1] = motor[Right_Arm_2] = trim;
		else if (SensorValue(Arm_Potentiometer) < 1200)
			motor[Left_Arm_1] = motor[Left_Arm_2] = motor[Right_Arm_1] = motor[Right_Arm_2] = -10;
		else
			motor[Left_Arm_1] = motor[Left_Arm_2] = motor[Right_Arm_1] = motor[Right_Arm_2] = 0;



		if (vexRT[Btn6U] == 1 && SensorValue[Claw_Potentiometer] < 3400)
		{
			open = true;
			claw(-127);
		}
		else if (vexRT[Btn6D] == 1 && SensorValue(Claw_Potentiometer) > 1000)
		{
			open = false;
			claw(127);
		}
		else if (SensorValue(Claw_Potentiometer) > 3430)
			claw(60);
		else if (SensorValue(Claw_Potentiometer) > 3700)
			claw(80);
		else if (SensorValue(Claw_Potentiometer) > 3900)
			claw(100);
		else if (open || SensorValue(Claw_Potentiometer) < 1600)
			claw(0);
		else
			claw(8);
	}
}
